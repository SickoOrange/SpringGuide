#### Git：Fast Forward提交机制，Merge机制

提交到远程中心仓库的代码必须是按照时间顺序的。而这个时间顺序并不是你本地的commit的时间顺序，而是多人协作的时候往远程中心仓库push的时间点！举个例子，比如

先考虑一下这个场景：

​	A:	/ 4 <- 5

1 <- 2 <- 3

​	B:	\6 <-7

A开发者在本地提交了4 跟5 这两个commit 

B开发者在本地提交了6跟7 两个commit

然后A 成功push到了远程仓库，然后B在push到远程仓库



- A为什么能够成功的push到远程仓库

  Git在push到远程仓库就是遵从所谓的Fast Forward模式，提交到中心仓库的代码必须按照远程仓库最新提交的commit的时间顺序线性提交。在一开始远程的中心仓库提交记录为1 <- 2 <- 3

  随后A跟B各自clone到本地进行开发，然后在提交，原则上此时A跟B谁先push谁就能成功提交到远程仓库，谁后谁就不能push，原理很简单，因为A跟B的的commit都是指向远程仓库最新的commit

- B为什么不能成功的push到远程仓库

  那么在A推送到远程仓库之后，远程的仓库commit记录就变成如下

  1 <- 2 <- 3 <- 4 <- 5

  ​	B:	\6 <-7

  我们的B的提交记录指向的依旧是commit3这个位置，但是远程仓库的最新commit已经到了5，所以B不能提交，因为此时B处于Non Fast Forward！

  此时如果强行提交的话，对于远程仓库的commit 4跟5，git无法判断是跟commit6与7合并，还是覆盖！

  这就是所谓的冲突了

- B如何才能push到远程仓库

  解决办法可以使用Git Pull这个命令！pull命令本质上是git fetch跟git merge的组合！

  使用git pull的本质其实就是将远程仓库最新的提交记录克隆到本地

  在本地由开发者自己决定是合并，还是覆盖！然后在进行push提交到远程仓库即可！

  他的原理就是通过git pull将远程的更新拉下来并且与本地的合并，如果有冲突就改掉冲突，这个时候会生成一个新的merge commit

  此时在B的本地分支提交记录变为这个样子：

  远程master分支	1 <- 2 <- 3 <- 4 <- 5

  

  B:  				1 <- 2 <- 3 <- 4 <- 5  \

  ​							\6 <-7 <- merge commit 

  看到没有 此时b的最新分支也指向5， 而远端的master分支最新的commit分支也是5

  这就是为什么使用git pull之后能够将b也推送到远程master分支的原因！

  git fetch 其实就是将指定的的分支最新的commit所有修改拉取到本地，通常他直降最新的内容拉取到本地，至于怎么处理这些最新的内容需要自己去决定！比如常见的就是 git fetch git merge=git pull！ 当然git fetch也有很多很强大的功能，这里就不再细说

#### Git Rebase

git rebase 和git merge 做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。

merge会在每次合并别的分支的时候为本地分支引入一个外来的合并提交。如果上游分支 非常活跃的话，这或多或少会污染你的分支历史

rebase 它会把整个 feature 分支提交记录移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来 但是，rebase 为原分支上每一个提交重新创建一个新的提交，重写了项目历史，并且不会带来合并提交

rebase的优点

- rebase最大的好处是你的项目历史会非常整洁 
- 支上提交历史完整的控制：你可以在分支的历史提交记录上做任何的更改，对 任何的更改都可以！如果说我删除掉一些不用的提交，获取将某些提交合并为一个提交记录，我可以将自己想要保留的提交保留下来，甚至可以篡改提交的msg信息！功能十分强大

rebase的缺点：

- 分支局限性，所谓的分支局限性就是 你当前工作的分支只能是你自己的分支，也就是说没有其他的人会在这个分支上进行开发
- 与git merge互斥，也就是说同一个分支 只能在git merge 跟git rebase中选择一个，并且一直使用下去 不能交替使用！
- 分支的强制推送：如果你想把 rebase 之后的 分支推送到远程仓库，Git 会阻止你这么做，因为两个分支包含冲突。因为经过rebase以后，你的当前分支的结构已经发生了改变，因为正如我之前说的，rebase会为你的本地的每一个commit重新生成一个新的commit！但你可以传入 –force 标记来强行推送，这是比较危险的做法，因为这样就等于是强制的改变的远程的仓库！如果你在本地乱改乱花无所谓大不了重新reset一下跟远程仓库保持一致就好，但是如果你rebase并且强制push到远程仓库了，如果出了问题，那么你就可以准备跑路了！