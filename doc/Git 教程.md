#### Git：Fast Forward提交机制，Merge机制

提交到远程中心仓库的代码必须是按照时间顺序的。而这个时间顺序并不是你本地的commit的时间顺序，而是多人协作的时候往远程中心仓库push的时间点！举个例子，比如

先考虑一下这个场景：

​	A:	/ 4 <- 5

1 <- 2 <- 3

​	B:	\6 <-7

A开发者在本地提交了4 跟5 这两个commit 

B开发者在本地提交了6跟7 两个commit

然后A 成功push到了远程仓库，然后B在push到远程仓库



- A为什么能够成功的push到远程仓库

  Git在push到远程仓库就是遵从所谓的Fast Forward模式，提交到中心仓库的代码必须按照远程仓库最新提交的commit的时间顺序线性提交。在一开始远程的中心仓库提交记录为1 <- 2 <- 3

  随后A跟B各自clone到本地进行开发，然后在提交，原则上此时A跟B谁先push谁就能成功提交到远程仓库，谁后谁就不能push，原理很简单，因为A跟B的的commit都是指向远程仓库最新的commit

- B为什么不能成功的push到远程仓库

  那么在A推送到远程仓库之后，远程的仓库commit记录就变成如下

  1 <- 2 <- 3 <- 4 <- 5

  ​	B:	\6 <-7

  我们的B的提交记录指向的依旧是commit3这个位置，但是远程仓库的最新commit已经到了5，所以B不能提交，因为此时B处于Non Fast Forward！

  此时如果强行提交的话，对于远程仓库的commit 4跟5，git无法判断是跟commit6与7合并，还是覆盖！

  这就是所谓的冲突了

- B如何才能push到远程仓库

  解决办法可以使用Git Pull这个命令！pull命令本质上是git fetch跟git merge的组合！

  使用git pull的本质其实就是将远程仓库最新的提交记录克隆到本地

  在本地由开发者自己决定是合并，还是覆盖！然后在进行push提交到远程仓库即可！

  他的原理就是通过git pull将远程的更新拉下来并且与本地的合并，如果有冲突就改掉冲突，这个时候会生成一个新的merge commit

  此时在B的本地分支提交记录变为这个样子：

  远程master分支	1 <- 2 <- 3 <- 4 <- 5

  

  B:  				1 <- 2 <- 3 <- 4 <- 5  \

  ​							\6 <-7 <- merge commit 

  看到没有 此时b的最新分支也指向5， 而远端的master分支最新的commit分支也是5

  这就是为什么使用git pull之后能够将b也推送到远程master分支的原因！

  git fetch 其实就是将指定的的分支最新的commit所有修改拉取到本地，通常他直降最新的内容拉取到本地，至于怎么处理这些最新的内容需要自己去决定！比如常见的就是 git fetch git merge=git pull！ 当然git fetch也有很多很强大的功能，这里就不再细说

##### git merge在云龙上dev回合到mastery的一个场景

首先在dev分支，git pull 更新代码，然后 git merge orgin master，然后解决冲突 提交到dev远端仓库，在云龙上合并！

![屏幕快照 2019-03-22 上午1.06.45](/Users/yayin/Desktop/屏幕快照 2019-03-22 上午1.06.45.png)

#### Git Rebase

git rebase 和git merge 做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。

merge会在每次合并别的分支的时候为本地分支引入一个外来的合并提交。如果上游分支 非常活跃的话，这或多或少会污染你的分支历史

rebase 它会把整个 feature 分支提交记录移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来 但是，rebase 为原分支上每一个提交重新创建一个新的提交，重写了项目历史，并且不会带来合并提交

rebase的优点

- rebase最大的好处是你的项目历史会非常整洁 
- 支上提交历史完整的控制：你可以在分支的历史提交记录上做任何的更改，对 任何的更改都可以！如果说我删除掉一些不用的提交，获取将某些提交合并为一个提交记录，我可以将自己想要保留的提交保留下来，甚至可以篡改提交的msg信息！功能十分强大

rebase的缺点：

- 分支局限性，所谓的分支局限性就是 你当前工作的分支只能是你自己的分支，也就是说没有其他的人会在这个分支上进行开发
- 与git merge互斥，也就是说同一个分支 只能在git merge 跟git rebase中选择一个，并且一直使用下去 不能交替使用！
- 分支的强制推送：如果你想把 rebase 之后的 分支推送到远程仓库，Git 会阻止你这么做，因为两个分支包含冲突。因为经过rebase以后，你的当前分支的结构已经发生了改变，因为正如我之前说的，rebase会为你的本地的每一个commit重新生成一个新的commit！但你可以传入 –force 标记来强行推送，这是比较危险的做法，因为这样就等于是强制的改变的远程的仓库！如果你在本地乱改乱花无所谓大不了重新reset一下跟远程仓库保持一致就好，但是如果你rebase并且强制push到远程仓库了，如果出了问题，那么你就可以准备跑路了！



#### Git Reset

简单来说reset就是一个可以让你在工作去，暂存区跟本地版本库之间任意穿梭跟移动的这样一个神奇的命令。

他一共有三种用法，并且三种用法的目的都是讲你当前分支的head指针指向一个特定的commit，但是他们之间也有比较大的区别！

- git reset --soft

  --soft参数告诉Git重置HEAD到另外一个commit，但也到此为止。回退到指定的commit，,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态, 文件的修改记录也会保存下来，不会更改！

  这个时候 你所有在指定commit之后提交的commit都在你的暂存区之中，如果需要提交到本地版本库，需要再一次commit！同时这种方法也可以修改提交的历史记录，将多个commit合并为一个commit，并且修改commit的信息！

- git reset --mix =git reset的默认形式

  跟soft的原理基本一致，只不过所有在指定commit之后提交的commnit内容都会被回退到工作区，同时这种方法也可以修改提交的历史记录，将多个commit合并为一个commit，并且修改commit的信息！

  这个时候如果要提交到版本库，需要重新add 然后在commit，如果有些文件已经add到了暂存区，但是不想提交 可以使用checkout +文件名 将指定文件会退到工作区

  mix比soft好的一点就是，他可以重新add指定的文件，也就是说有些文件我不想提交的话，可以就不用add了！

- git reset --hard

  这是一个比较危险的命令，因为它不仅可以江head指向指定的commit，而且在指定commit之后的所有的commit修改都会丢掉，也就是说彻底还原到了指定commity的这个时候！使用的时候要慎用！当然如果真的不小心丢掉了所有的commit信息，也可以找回来 可以使用git reflog！ 在git中所有的提交信息都会保存起来，所有即使你丢失掉了一些commit 也是可以复原，但是如果你丢掉的是没有commit的修改，那你就赶紧跑路吧！

##### 三种命令横向对比：

在讲这个之前先讲一下，其实在初始化一个仓库之后，本地三个区都是保持一致的，

你在本地的任何增删改查都是体现在工作区上，通过增删改查 工作区跟暂存区的内容都在发生改变！

逐渐与版本库发生了偏离！最终通过commit，使得三个工作区再一次保持一致！

![屏幕快照 2019-03-22 上午12.50.09](/Users/yayin/Desktop/屏幕快照 2019-03-22 上午12.50.09.png)

git reset soft

会讲工作区跟暂存区后回退到指定commit，其实就是经过了git add，但是还没有commit

![屏幕快照 2019-03-22 上午12.34.28](/Users/yayin/Desktop/屏幕快照 2019-03-22 上午12.34.28.png)

git reset mix：

区别就是讲所有改动回退到工作区，所以本质上就是改动了文件还没有经历git add这个过程！

![屏幕快照 2019-03-22 上午12.38.20](/Users/yayin/Desktop/屏幕快照 2019-03-22 上午12.38.20.png)

##### git reset在工作场景中解决push冲突的一种有效办法

通常我在工作中在push代码上库之前都是通过git reset+git stash来解决冲突！这是一种高效节省时间的方法！



首先说说 如果你忘记了pull 代码 直接push到远端，提示有冲突push不上去 获取push上去了，但是不能顺利sumint何如，

此时继绝办法如下：

首先查看git log历史，查看你在开始修改的之前一个commit，使用git reset --soft或者mix，江当前你的本地版本库的代码会退到这个commit之上，此时你的全部修改都将全部的保留，然后在git pull远端仓库的代码，在本地解决冲突！然后在重新git add 或使用smart ide去提交，就可以了！

如果你想在解决冲突之前查看远端的修改，你可以先试用git stage将你本地所有的修改暂存起来，然后在git pull，看完远端的修改，你在git unstage将你本地的修改全都恢复，在解决冲突即可！

